import React, { forwardRef, useImperativeHandle, useRef } from 'react';
import { StyleSheet, View, TouchableOpacity, Text, Dimensions, Animated, PanResponder, Modal, SafeAreaView, StatusBar, Image, } from 'react-native';
var LONG_PRESS_TIME = 800;
var DOUBLE_CLICK_INTERVAL = 250;
var MAX_OVERFLOW = 100;
var MIN_SCALE = 0.6;
var MAX_SCALE = 10;
var CLICK_DISTANCE = 10;
var DRAG_DISMISS_THRESHOLD = 150;
var Styles = StyleSheet.create({
    background: {
        position: 'absolute',
        top: 0,
        left: 0,
        width: '100%',
        height: '100%',
    },
    header: {
        position: 'absolute',
        top: 0,
        left: 0,
        width: '100%',
        backgroundColor: 'transparent',
    },
    footer: {
        position: 'absolute',
        bottom: 0,
        left: 0,
        width: '100%',
        backgroundColor: 'transparent',
    },
    closeButton: {
        fontSize: 35,
        color: 'white',
        lineHeight: 40,
        width: 40,
        textAlign: 'center',
        shadowOffset: {
            width: 0,
            height: 0,
        },
        shadowRadius: 1.5,
        shadowColor: 'black',
        shadowOpacity: 0.8,
    },
});
var ImageDetail = forwardRef(function (_a, ref) {
    var renderToHardwareTextureAndroid = _a.renderToHardwareTextureAndroid, isTranslucent = _a.isTranslucent, isOpen = _a.isOpen, origin = _a.origin, source = _a.source, _b = _a.resizeMode, resizeMode = _b === void 0 ? 'contain' : _b, _c = _a.backgroundColor, backgroundColor = _c === void 0 ? '#000000' : _c, swipeToDismiss = _a.swipeToDismiss, hideCloseButton = _a.hideCloseButton, imageStyle = _a.imageStyle, renderHeader = _a.renderHeader, renderFooter = _a.renderFooter, renderImageComponent = _a.renderImageComponent, onTap = _a.onTap, onDoubleTap = _a.onDoubleTap, onLongPress = _a.onLongPress, didOpen = _a.didOpen, onMove = _a.onMove, responderRelease = _a.responderRelease, willClose = _a.willClose, onClose = _a.onClose;
    var _animatedScale = new Animated.Value(1);
    var _animatedPositionX = new Animated.Value(0);
    var _animatedPositionY = new Animated.Value(0);
    var _animatedFrame = new Animated.Value(0);
    var _animatedOpacity = new Animated.Value(Dimensions.get('window').height);
    var _lastPositionX = useRef(null);
    var _lastPositionY = useRef(null);
    var _zoomLastDistance = useRef(null);
    var _horizontalWholeCounter = useRef(0);
    var _verticalWholeCounter = useRef(0);
    var _isDoubleClick = useRef(false);
    var _isLongPress = useRef(false);
    var _centerDiffX = useRef(0);
    var _centerDiffY = useRef(0);
    var _singleClickTimeout = useRef(undefined);
    var _longPressTimeout = useRef(undefined);
    var _lastClickTime = useRef(0);
    var _doubleClickX = useRef(0);
    var _doubleClickY = useRef(0);
    var _scale = useRef(1);
    var _positionX = useRef(0);
    var _positionY = useRef(0);
    var _zoomCurrentDistance = useRef(0);
    var _swipeDownOffset = useRef(0);
    var _horizontalWholeOuterCounter = useRef(0);
    var _isAnimated = useRef(false);
    var _imagePanResponder = PanResponder.create({
        onStartShouldSetPanResponder: function () { return true; },
        onPanResponderTerminationRequest: function () { return false; },
        onPanResponderGrant: function (evt) {
            if (_isAnimated.current) {
                return;
            }
            var windowWidth = Dimensions.get('window').width;
            var windowHeight = Dimensions.get('window').height;
            _lastPositionX.current = null;
            _lastPositionY.current = null;
            _zoomLastDistance.current = null;
            _horizontalWholeCounter.current = 0;
            _verticalWholeCounter.current = 0;
            _isDoubleClick.current = false;
            _isLongPress.current = false;
            if (_singleClickTimeout.current) {
                clearTimeout(_singleClickTimeout.current);
                _singleClickTimeout.current = undefined;
            }
            if (evt.nativeEvent.changedTouches.length > 1) {
                var centerX = (evt.nativeEvent.changedTouches[0].pageX + evt.nativeEvent.changedTouches[1].pageX) / 2;
                _centerDiffX.current = centerX - windowWidth / 2;
                var centerY = (evt.nativeEvent.changedTouches[0].pageY + evt.nativeEvent.changedTouches[1].pageY) / 2;
                _centerDiffY.current = centerY - windowHeight / 2;
            }
            if (_longPressTimeout.current) {
                clearTimeout(_longPressTimeout.current);
                _longPressTimeout.current = undefined;
            }
            _longPressTimeout.current = setTimeout(function () {
                _isLongPress.current = true;
                onLongPress === null || onLongPress === void 0 ? void 0 : onLongPress();
            }, LONG_PRESS_TIME);
            if (evt.nativeEvent.changedTouches.length <= 1) {
                if (new Date().getTime() - _lastClickTime.current < (DOUBLE_CLICK_INTERVAL || 0)) {
                    _lastClickTime.current = 0;
                    onDoubleTap === null || onDoubleTap === void 0 ? void 0 : onDoubleTap();
                    clearTimeout(_longPressTimeout.current);
                    _longPressTimeout.current = undefined;
                    _doubleClickX.current = evt.nativeEvent.changedTouches[0].pageX;
                    _doubleClickY.current = evt.nativeEvent.changedTouches[0].pageY;
                    _isDoubleClick.current = true;
                    if (_scale.current > 1 || _scale.current < 1) {
                        _scale.current = 1;
                        _positionX.current = 0;
                        _positionY.current = 0;
                    }
                    else {
                        var beforeScale = _scale.current;
                        _scale.current = 2;
                        var diffScale = _scale.current - beforeScale;
                        _positionX.current =
                            ((windowWidth / 2 - _doubleClickX.current) * diffScale) / _scale.current;
                        _positionY.current =
                            ((windowHeight / 2 - _doubleClickY.current) * diffScale) / _scale.current;
                    }
                    _imageDidMove('centerOn');
                    Animated.parallel([
                        Animated.timing(_animatedScale, {
                            toValue: _scale.current,
                            duration: 100,
                            useNativeDriver: false,
                        }),
                        Animated.timing(_animatedPositionX, {
                            toValue: _positionX.current,
                            duration: 100,
                            useNativeDriver: false,
                        }),
                        Animated.timing(_animatedPositionY, {
                            toValue: _positionY.current,
                            duration: 100,
                            useNativeDriver: false,
                        }),
                    ]).start();
                }
                else {
                    _lastClickTime.current = new Date().getTime();
                }
            }
        },
        onPanResponderMove: function (evt, gestureState) {
            if (_isDoubleClick.current || _isAnimated.current) {
                return;
            }
            if (evt.nativeEvent.changedTouches.length <= 1) {
                var diffX = gestureState.dx - (_lastPositionX.current || 0);
                if (_lastPositionX === null) {
                    diffX = 0;
                }
                var diffY = gestureState.dy - (_lastPositionY.current || 0);
                if (_lastPositionY === null) {
                    diffY = 0;
                }
                var windowWidth_1 = Dimensions.get('window').width;
                _lastPositionX.current = gestureState.dx;
                _lastPositionY.current = gestureState.dy;
                _horizontalWholeCounter.current += diffX;
                _verticalWholeCounter.current += diffY;
                if ((Math.abs(_horizontalWholeCounter.current) > 5 ||
                    Math.abs(_verticalWholeCounter.current) > 5) &&
                    _longPressTimeout.current) {
                    clearTimeout(_longPressTimeout.current);
                    _longPressTimeout.current = undefined;
                }
                if (_swipeDownOffset.current === 0) {
                    if (windowWidth_1 * _scale.current > windowWidth_1) {
                        if (_horizontalWholeOuterCounter.current > 0) {
                            if (diffX < 0) {
                                if (_horizontalWholeOuterCounter.current > Math.abs(diffX)) {
                                    _horizontalWholeOuterCounter.current += diffX;
                                    diffX = 0;
                                }
                                else {
                                    diffX += _horizontalWholeOuterCounter.current;
                                    _horizontalWholeOuterCounter.current = 0;
                                }
                            }
                            else {
                                _horizontalWholeOuterCounter.current += diffX;
                            }
                        }
                        else if (_horizontalWholeOuterCounter.current < 0) {
                            if (diffX > 0) {
                                if (Math.abs(_horizontalWholeOuterCounter.current) > diffX) {
                                    _horizontalWholeOuterCounter.current += diffX;
                                    diffX = 0;
                                }
                                else {
                                    diffX += _horizontalWholeOuterCounter.current;
                                    _horizontalWholeOuterCounter.current = 0;
                                }
                            }
                            else {
                                _horizontalWholeOuterCounter.current += diffX;
                            }
                        }
                        _positionX.current += diffX / _scale.current;
                        var horizontalMax = (windowWidth_1 * _scale.current - windowWidth_1) / 2 / _scale.current;
                        if (_positionX.current < -horizontalMax) {
                            _positionX.current = -horizontalMax;
                            _horizontalWholeOuterCounter.current += -1 / 1e10;
                        }
                        else if (_positionX.current > horizontalMax) {
                            _positionX.current = horizontalMax;
                            _horizontalWholeOuterCounter.current += 1 / 1e10;
                        }
                        _animatedPositionX.setValue(_positionX.current);
                    }
                    else {
                        _horizontalWholeOuterCounter.current += diffX;
                    }
                    if (_horizontalWholeOuterCounter.current > (MAX_OVERFLOW || 0)) {
                        _horizontalWholeOuterCounter.current = MAX_OVERFLOW || 0;
                    }
                    else if (_horizontalWholeOuterCounter.current < -(MAX_OVERFLOW || 0)) {
                        _horizontalWholeOuterCounter.current = -(MAX_OVERFLOW || 0);
                    }
                }
                _positionY.current += diffY / _scale.current;
                _animatedPositionY.setValue(_positionY.current);
                if (swipeToDismiss && _scale.current === 1) {
                    _animatedOpacity.setValue(Math.abs(gestureState.dy));
                }
            }
            else {
                if (_longPressTimeout.current) {
                    clearTimeout(_longPressTimeout.current);
                    _longPressTimeout.current = undefined;
                }
                var minX = void 0;
                var maxX = void 0;
                if (evt.nativeEvent.changedTouches[0].locationX >
                    evt.nativeEvent.changedTouches[1].locationX) {
                    minX = evt.nativeEvent.changedTouches[1].pageX;
                    maxX = evt.nativeEvent.changedTouches[0].pageX;
                }
                else {
                    minX = evt.nativeEvent.changedTouches[0].pageX;
                    maxX = evt.nativeEvent.changedTouches[1].pageX;
                }
                var minY = void 0;
                var maxY = void 0;
                if (evt.nativeEvent.changedTouches[0].locationY >
                    evt.nativeEvent.changedTouches[1].locationY) {
                    minY = evt.nativeEvent.changedTouches[1].pageY;
                    maxY = evt.nativeEvent.changedTouches[0].pageY;
                }
                else {
                    minY = evt.nativeEvent.changedTouches[0].pageY;
                    maxY = evt.nativeEvent.changedTouches[1].pageY;
                }
                var widthDistance = maxX - minX;
                var heightDistance = maxY - minY;
                var diagonalDistance = Math.sqrt(widthDistance * widthDistance + heightDistance * heightDistance);
                _zoomCurrentDistance.current = Number(diagonalDistance.toFixed(1));
                if (_zoomLastDistance.current !== null) {
                    var distanceDiff = (_zoomCurrentDistance.current - _zoomLastDistance.current) / 200;
                    var zoom = _scale.current + distanceDiff;
                    if (zoom < MIN_SCALE) {
                        zoom = MIN_SCALE;
                    }
                    if (zoom > MAX_SCALE) {
                        zoom = MAX_SCALE;
                    }
                    var beforeScale = _scale;
                    _scale.current = zoom;
                    _animatedScale.setValue(_scale.current);
                    var diffScale = _scale.current - beforeScale.current;
                    _positionX.current -= (_centerDiffX.current * diffScale) / _scale.current;
                    _positionY.current -= (_centerDiffY.current * diffScale) / _scale.current;
                    _animatedPositionX.setValue(_positionX.current);
                    _animatedPositionY.setValue(_positionY.current);
                }
                _zoomLastDistance.current = _zoomCurrentDistance.current;
            }
            _imageDidMove('onPanResponderMove');
        },
        onPanResponderRelease: function (evt, gestureState) {
            if (_longPressTimeout.current) {
                clearTimeout(_longPressTimeout.current);
                _longPressTimeout.current = undefined;
            }
            if (_isDoubleClick.current || _isLongPress.current || _isAnimated.current) {
                return;
            }
            var moveDistance = Math.sqrt(gestureState.dx * gestureState.dx + gestureState.dy * gestureState.dy);
            var _a = evt.nativeEvent, locationX = _a.locationX, locationY = _a.locationY, pageX = _a.pageX, pageY = _a.pageY;
            if (evt.nativeEvent.changedTouches.length === 1 && moveDistance < CLICK_DISTANCE) {
                _singleClickTimeout.current = setTimeout(function () {
                    onTap === null || onTap === void 0 ? void 0 : onTap({ locationX: locationX, locationY: locationY, pageX: pageX, pageY: pageY });
                }, DOUBLE_CLICK_INTERVAL);
            }
            else {
                responderRelease === null || responderRelease === void 0 ? void 0 : responderRelease(gestureState.vx, _scale.current);
                _panResponderReleaseResolve(evt.nativeEvent.changedTouches.length);
            }
        },
    });
    var _imageDidMove = function (type) {
        onMove === null || onMove === void 0 ? void 0 : onMove({
            type: type,
            positionX: _positionX.current,
            positionY: _positionY.current,
            scale: _scale.current,
            zoomCurrentDistance: _zoomCurrentDistance.current,
        });
    };
    var _panResponderReleaseResolve = function (changedTouchesCount) {
        var windowWidth = Dimensions.get('window').width;
        var windowHeight = Dimensions.get('window').height;
        if (_scale.current < 1) {
            _scale.current = 1;
            Animated.timing(_animatedScale, {
                toValue: _scale.current,
                duration: 100,
                useNativeDriver: false,
            }).start();
        }
        if (windowWidth * _scale.current <= windowWidth) {
            _positionX.current = 0;
            Animated.timing(_animatedPositionX, {
                toValue: _positionX.current,
                duration: 100,
                useNativeDriver: false,
            }).start();
        }
        if (windowHeight * _scale.current < windowHeight) {
            _positionY.current = 0;
            Animated.timing(_animatedPositionY, {
                toValue: _positionY.current,
                duration: 100,
                useNativeDriver: false,
            }).start();
        }
        else if (swipeToDismiss &&
            _scale.current === 1 &&
            changedTouchesCount === 1 &&
            Math.abs(_positionY.current) > DRAG_DISMISS_THRESHOLD) {
            handleClose();
            return;
        }
        if (windowHeight * _scale.current > windowHeight) {
            var verticalMax = (windowHeight * _scale.current - windowHeight) / 2 / _scale.current;
            if (_positionY.current < -verticalMax) {
                _positionY.current = -verticalMax;
            }
            else if (_positionY.current > verticalMax) {
                _positionY.current = verticalMax;
            }
            Animated.timing(_animatedPositionY, {
                toValue: _positionY.current,
                duration: 100,
                useNativeDriver: false,
            }).start();
        }
        if (windowWidth * _scale.current > windowWidth) {
            var horizontalMax = (windowWidth * _scale.current - windowWidth) / 2 / _scale.current;
            if (_positionX.current < -horizontalMax) {
                _positionX.current = -horizontalMax;
            }
            else if (_positionX.current > horizontalMax) {
                _positionX.current = horizontalMax;
            }
            Animated.timing(_animatedPositionX, {
                toValue: _positionX.current,
                duration: 100,
                useNativeDriver: false,
            }).start();
        }
        if (_scale.current === 1) {
            _positionX.current = 0;
            _positionY.current = 0;
            Animated.timing(_animatedPositionX, {
                toValue: _positionX.current,
                duration: 100,
                useNativeDriver: false,
            }).start();
            Animated.timing(_animatedPositionY, {
                toValue: _positionY.current,
                duration: 100,
                useNativeDriver: false,
            }).start();
        }
        Animated.timing(_animatedOpacity, {
            toValue: 0,
            duration: 100,
            useNativeDriver: false,
        }).start();
        _horizontalWholeOuterCounter.current = 0;
        _swipeDownOffset.current = 0;
        _imageDidMove('onPanResponderRelease');
    };
    var handleClose = function () {
        var windowHeight = Dimensions.get('window').height;
        if (isTranslucent) {
            StatusBar.setHidden(false);
        }
        setTimeout(function () {
            _isAnimated.current = true;
            willClose === null || willClose === void 0 ? void 0 : willClose();
            Animated.parallel([
                Animated.timing(_animatedScale, { toValue: 1, useNativeDriver: false }),
                Animated.timing(_animatedPositionX, { toValue: 0, useNativeDriver: false }),
                Animated.timing(_animatedPositionY, { toValue: 0, useNativeDriver: false }),
                Animated.timing(_animatedOpacity, { toValue: windowHeight, useNativeDriver: false }),
                Animated.spring(_animatedFrame, { toValue: 0, useNativeDriver: false }),
            ]).start(function () {
                onClose();
                _isAnimated.current = false;
            });
        });
    };
    var windowWidth = Dimensions.get('window').width;
    var windowHeight = Dimensions.get('window').height;
    var animateConf = {
        transform: [
            {
                scale: _animatedScale,
            },
            {
                translateX: _animatedPositionX,
            },
            {
                translateY: _animatedPositionY,
            },
        ],
        left: _animatedFrame.interpolate({
            inputRange: [0, 1],
            outputRange: [origin.x, 0],
        }),
        top: _animatedFrame.interpolate({
            inputRange: [0, 1],
            outputRange: [origin.y, 0],
        }),
        width: _animatedFrame.interpolate({
            inputRange: [0, 1],
            outputRange: [origin.width, windowWidth],
        }),
        height: _animatedFrame.interpolate({
            inputRange: [0, 1],
            outputRange: [origin.height, windowHeight],
        }),
    };
    var background = (<Animated.View renderToHardwareTextureAndroid={renderToHardwareTextureAndroid} style={[
            Styles.background,
            { backgroundColor: backgroundColor },
            {
                opacity: _animatedOpacity.interpolate({
                    inputRange: [0, windowHeight],
                    outputRange: [1, 0],
                }),
            },
        ]}></Animated.View>);
    var header = (<Animated.View renderToHardwareTextureAndroid={renderToHardwareTextureAndroid} style={[
            Styles.header,
            {
                opacity: _animatedOpacity.interpolate({
                    inputRange: [0, windowHeight],
                    outputRange: [1, 0],
                }),
            },
        ]}>
        {typeof renderHeader === 'function' ? (renderHeader(handleClose)) : !hideCloseButton ? (<SafeAreaView style={{ marginTop: isTranslucent ? StatusBar.currentHeight : 0 }}>
            <TouchableOpacity onPress={handleClose}>
              <Text style={Styles.closeButton}>×</Text>
            </TouchableOpacity>
          </SafeAreaView>) : undefined}
      </Animated.View>);
    var footer = renderFooter && (<Animated.View renderToHardwareTextureAndroid={renderToHardwareTextureAndroid} style={[
            Styles.footer,
            {
                opacity: _animatedOpacity.interpolate({
                    inputRange: [0, windowHeight],
                    outputRange: [1, 0],
                }),
            },
        ]}>
        {renderFooter(handleClose)}
      </Animated.View>);
    var content = (<View style={{
            overflow: 'hidden',
            width: '100%',
            height: '100%',
            flex: 1,
        }} {..._imagePanResponder === null || _imagePanResponder === void 0 ? void 0 : _imagePanResponder.panHandlers}>
        {background}
        <Animated.View style={animateConf} renderToHardwareTextureAndroid={renderToHardwareTextureAndroid}>
          {typeof renderImageComponent === 'function' ? (renderImageComponent({
            source: source,
            resizeMode: resizeMode,
            style: [
                imageStyle,
                {
                    width: '100%',
                    height: '100%',
                },
            ],
        })) : (<Image resizeMode={resizeMode} style={[
                imageStyle,
                {
                    width: '100%',
                    height: '100%',
                },
            ]} source={source}/>)}
        </Animated.View>
        {header}
        {typeof renderFooter === 'function' && footer}
      </View>);
    Animated.parallel([
        Animated.timing(_animatedOpacity, { toValue: 0, useNativeDriver: false }),
        Animated.spring(_animatedFrame, { toValue: 1, useNativeDriver: false }),
    ]).start(function () {
        _isAnimated.current = false;
        if (isOpen) {
            didOpen === null || didOpen === void 0 ? void 0 : didOpen();
        }
    });
    useImperativeHandle(ref, function () { return ({
        close: function () {
            handleClose();
        },
    }); });
    return (<Modal hardwareAccelerated visible={isOpen} transparent statusBarTranslucent={isTranslucent} onRequestClose={handleClose} supportedOrientations={[
            'portrait',
            'portrait-upside-down',
            'landscape',
            'landscape-left',
            'landscape-right',
        ]}>
        {isTranslucent && <StatusBar backgroundColor={'transparent'} translucent={true}/>}
        {content}
      </Modal>);
});
export default ImageDetail;
//# sourceMappingURL=index.js.map